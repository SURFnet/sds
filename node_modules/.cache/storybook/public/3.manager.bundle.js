(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[3],{

/***/ "./node_modules/@figspec/react/esm/es2015/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@figspec/react/esm/es2015/index.js + 37 modules ***!
  \**********************************************************************/
/*! exports provided: FigspecFrameViewer, FigspecFileViewer */
/*! exports used: FigspecFileViewer, FigspecFrameViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ es2015_FigspecFrameViewer; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ es2015_FigspecFileViewer; });

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/css-tag.js
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const css_tag_t=window.ShadowRoot&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,css_tag_e=Symbol(),css_tag_n=new Map;class css_tag_s{constructor(t,n){if(this._$cssResult$=!0,n!==css_tag_e)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t}get styleSheet(){let e=css_tag_n.get(this.cssText);return css_tag_t&&void 0===e&&(css_tag_n.set(this.cssText,e=new CSSStyleSheet),e.replaceSync(this.cssText)),e}toString(){return this.cssText}}const css_tag_o=t=>new css_tag_s("string"==typeof t?t:t+"",css_tag_e),css_tag_r=(t,...n)=>{const o=1===t.length?t[0]:n.reduce(((e,n,s)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(n)+t[s+1]),t[0]);return new css_tag_s(o,css_tag_e)},css_tag_i=(e,n)=>{css_tag_t?e.adoptedStyleSheets=n.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):n.forEach((t=>{const n=document.createElement("style"),s=window.litNonce;void 0!==s&&n.setAttribute("nonce",s),n.textContent=t.cssText,e.appendChild(n)}))},S=css_tag_t?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const n of t.cssRules)e+=n.cssText;return css_tag_o(e)})(t):t;
//# sourceMappingURL=css-tag.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/reactive-element.js

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var reactive_element_s;const reactive_element_e=window.trustedTypes,reactive_element_r=reactive_element_e?reactive_element_e.emptyScript:"",h=window.reactiveElementPolyfillSupport,reactive_element_o={toAttribute(t,i){switch(i){case Boolean:t=t?reactive_element_r:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t)}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t)}catch(t){s=null}}return s}},reactive_element_n=(t,i)=>i!==t&&(i==i||t==t),reactive_element_l={attribute:!0,type:String,converter:reactive_element_o,reflect:!1,hasChanged:reactive_element_n};class reactive_element_a extends HTMLElement{constructor(){super(),this._$Et=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Ei=null,this.o()}static addInitializer(t){var i;null!==(i=this.l)&&void 0!==i||(this.l=[]),this.l.push(t)}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this._$Eh(s,i);void 0!==e&&(this._$Eu.set(e,s),t.push(e))})),t}static createProperty(t,i=reactive_element_l){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e)}}static getPropertyDescriptor(t,i,s){return{get(){return this[i]},set(e){const r=this[t];this[i]=e,this.requestUpdate(t,r,s)},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||reactive_element_l}static finalize(){if(this.hasOwnProperty("finalized"))return!1;this.finalized=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),this.elementProperties=new Map(t.elementProperties),this._$Eu=new Map,this.hasOwnProperty("properties")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s])}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift(S(i))}else void 0!==i&&s.push(S(i));return s}static _$Eh(t,i){const s=i.attribute;return!1===s?void 0:"string"==typeof s?s:"string"==typeof t?t.toLowerCase():void 0}o(){var t;this._$Ep=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$Em(),this.requestUpdate(),null===(t=this.constructor.l)||void 0===t||t.forEach((t=>t(this)))}addController(t){var i,s;(null!==(i=this._$Eg)&&void 0!==i?i:this._$Eg=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t))}removeController(t){var i;null===(i=this._$Eg)||void 0===i||i.splice(this._$Eg.indexOf(t)>>>0,1)}_$Em(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this._$Et.set(i,this[i]),delete this[i])}))}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return css_tag_i(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)}))}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)}))}attributeChangedCallback(t,i,s){this._$AK(t,s)}_$ES(t,i,s=reactive_element_l){var e,r;const h=this.constructor._$Eh(t,s);if(void 0!==h&&!0===s.reflect){const n=(null!==(r=null===(e=s.converter)||void 0===e?void 0:e.toAttribute)&&void 0!==r?r:reactive_element_o.toAttribute)(i,s.type);this._$Ei=t,null==n?this.removeAttribute(h):this.setAttribute(h,n),this._$Ei=null}}_$AK(t,i){var s,e,r;const h=this.constructor,n=h._$Eu.get(t);if(void 0!==n&&this._$Ei!==n){const t=h.getPropertyOptions(n),l=t.converter,a=null!==(r=null!==(e=null===(s=l)||void 0===s?void 0:s.fromAttribute)&&void 0!==e?e:"function"==typeof l?l:null)&&void 0!==r?r:reactive_element_o.fromAttribute;this._$Ei=n,this[n]=a(i,t.type),this._$Ei=null}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||reactive_element_n)(this[t],i)?(this._$AL.has(t)||this._$AL.set(t,i),!0===s.reflect&&this._$Ei!==t&&(void 0===this._$EC&&(this._$EC=new Map),this._$EC.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this._$Ep=this._$E_())}async _$E_(){this.isUpdatePending=!0;try{await this._$Ep}catch(t){Promise.reject(t)}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this._$Et&&(this._$Et.forEach(((t,i)=>this[i]=t)),this._$Et=void 0);let i=!1;const s=this._$AL;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this._$EU()}catch(t){throw i=!1,this._$EU(),t}i&&this._$AE(s)}willUpdate(t){}_$AE(t){var i;null===(i=this._$Eg)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t)}_$EU(){this._$AL=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$Ep}shouldUpdate(t){return!0}update(t){void 0!==this._$EC&&(this._$EC.forEach(((t,i)=>this._$ES(i,this[i],t))),this._$EC=void 0),this._$EU()}updated(t){}firstUpdated(t){}}reactive_element_a.finalized=!0,reactive_element_a.elementProperties=new Map,reactive_element_a.elementStyles=[],reactive_element_a.shadowRootOptions={mode:"open"},null==h||h({ReactiveElement:reactive_element_a}),(null!==(reactive_element_s=globalThis.reactiveElementVersions)&&void 0!==reactive_element_s?reactive_element_s:globalThis.reactiveElementVersions=[]).push("1.3.2");
//# sourceMappingURL=reactive-element.js.map

// CONCATENATED MODULE: ./node_modules/lit-html/lit-html.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var lit_html_t;const lit_html_i=globalThis.trustedTypes,lit_html_s=lit_html_i?lit_html_i.createPolicy("lit-html",{createHTML:t=>t}):void 0,lit_html_e=`lit$${(Math.random()+"").slice(9)}$`,lit_html_o="?"+lit_html_e,lit_html_n=`<${lit_html_o}>`,lit_html_l=document,lit_html_h=(t="")=>lit_html_l.createComment(t),lit_html_r=t=>null===t||"object"!=typeof t&&"function"!=typeof t,d=Array.isArray,u=t=>{var i;return d(t)||"function"==typeof(null===(i=t)||void 0===i?void 0:i[Symbol.iterator])},lit_html_c=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,lit_html_a=/>/g,f=/>|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g,_=/'/g,m=/"/g,g=/^(?:script|style|textarea|title)$/i,p=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),$=p(1),lit_html_y=p(2),b=Symbol.for("lit-noChange"),w=Symbol.for("lit-nothing"),T=new WeakMap,lit_html_x=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new N(i.insertBefore(lit_html_h(),t),t,void 0,null!=s?s:{})}return l._$AI(t),l},A=lit_html_l.createTreeWalker(lit_html_l,129,null,!1),C=(t,i)=>{const o=t.length-1,l=[];let h,r=2===i?"<svg>":"",d=lit_html_c;for(let i=0;i<o;i++){const s=t[i];let o,u,p=-1,$=0;for(;$<s.length&&(d.lastIndex=$,u=d.exec(s),null!==u);)$=d.lastIndex,d===lit_html_c?"!--"===u[1]?d=v:void 0!==u[1]?d=lit_html_a:void 0!==u[2]?(g.test(u[2])&&(h=RegExp("</"+u[2],"g")),d=f):void 0!==u[3]&&(d=f):d===f?">"===u[0]?(d=null!=h?h:lit_html_c,p=-1):void 0===u[1]?p=-2:(p=d.lastIndex-u[2].length,o=u[1],d=void 0===u[3]?f:'"'===u[3]?m:_):d===m||d===_?d=f:d===v||d===lit_html_a?d=lit_html_c:(d=f,h=void 0);const y=d===f&&t[i+1].startsWith("/>")?" ":"";r+=d===lit_html_c?s+lit_html_n:p>=0?(l.push(o),s.slice(0,p)+"$lit$"+s.slice(p)+lit_html_e+y):s+lit_html_e+(-2===p?(l.push(void 0),i):y)}const u=r+(t[o]||"<?>")+(2===i?"</svg>":"");if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return[void 0!==lit_html_s?lit_html_s.createHTML(u):u,l]};class E{constructor({strings:t,_$litType$:s},n){let l;this.parts=[];let r=0,d=0;const u=t.length-1,c=this.parts,[v,a]=C(t,s);if(this.el=E.createElement(v,n),A.currentNode=this.el.content,2===s){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes)}for(;null!==(l=A.nextNode())&&c.length<u;){if(1===l.nodeType){if(l.hasAttributes()){const t=[];for(const i of l.getAttributeNames())if(i.endsWith("$lit$")||i.startsWith(lit_html_e)){const s=a[d++];if(t.push(i),void 0!==s){const t=l.getAttribute(s.toLowerCase()+"$lit$").split(lit_html_e),i=/([.?@])?(.*)/.exec(s);c.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?M:"?"===i[1]?H:"@"===i[1]?I:lit_html_S})}else c.push({type:6,index:r})}for(const i of t)l.removeAttribute(i)}if(g.test(l.tagName)){const t=l.textContent.split(lit_html_e),s=t.length-1;if(s>0){l.textContent=lit_html_i?lit_html_i.emptyScript:"";for(let i=0;i<s;i++)l.append(t[i],lit_html_h()),A.nextNode(),c.push({type:2,index:++r});l.append(t[s],lit_html_h())}}}else if(8===l.nodeType)if(l.data===lit_html_o)c.push({type:2,index:r});else{let t=-1;for(;-1!==(t=l.data.indexOf(lit_html_e,t+1));)c.push({type:7,index:r}),t+=lit_html_e.length-1}r++}}static createElement(t,i){const s=lit_html_l.createElement("template");return s.innerHTML=t,s}}function P(t,i,s=t,e){var o,n,l,h;if(i===b)return i;let d=void 0!==e?null===(o=s._$Cl)||void 0===o?void 0:o[e]:s._$Cu;const u=lit_html_r(i)?void 0:i._$litDirective$;return(null==d?void 0:d.constructor)!==u&&(null===(n=null==d?void 0:d._$AO)||void 0===n||n.call(d,!1),void 0===u?d=void 0:(d=new u(t),d._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Cl)&&void 0!==l?l:h._$Cl=[])[e]=d:s._$Cu=d),void 0!==d&&(i=P(t,d._$AS(t,i.values),d,e)),i}class V{constructor(t,i){this.v=[],this._$AN=void 0,this._$AD=t,this._$AM=i}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}p(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:lit_html_l).importNode(s,!0);A.currentNode=o;let n=A.nextNode(),h=0,r=0,d=e[0];for(;void 0!==d;){if(h===d.index){let i;2===d.type?i=new N(n,n.nextSibling,this,t):1===d.type?i=new d.ctor(n,d.name,d.strings,this,t):6===d.type&&(i=new L(n,this,t)),this.v.push(i),d=e[++r]}h!==(null==d?void 0:d.index)&&(n=A.nextNode(),h++)}return o}m(t){let i=0;for(const s of this.v)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++}}class N{constructor(t,i,s,e){var o;this.type=2,this._$AH=w,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cg=null===(o=null==e?void 0:e.isConnected)||void 0===o||o}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cg}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=P(this,t,i),lit_html_r(t)?t===w||null==t||""===t?(this._$AH!==w&&this._$AR(),this._$AH=w):t!==this._$AH&&t!==b&&this.$(t):void 0!==t._$litType$?this.T(t):void 0!==t.nodeType?this.k(t):u(t)?this.S(t):this.$(t)}M(t,i=this._$AB){return this._$AA.parentNode.insertBefore(t,i)}k(t){this._$AH!==t&&(this._$AR(),this._$AH=this.M(t))}$(t){this._$AH!==w&&lit_html_r(this._$AH)?this._$AA.nextSibling.data=t:this.k(lit_html_l.createTextNode(t)),this._$AH=t}T(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=E.createElement(e.h,this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.m(s);else{const t=new V(o,this),i=t.p(this.options);t.m(s),this.k(i),this._$AH=t}}_$AC(t){let i=T.get(t.strings);return void 0===i&&T.set(t.strings,i=new E(t)),i}S(t){d(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new N(this.M(lit_html_h()),this.M(lit_html_h()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e)}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i}}setConnected(t){var i;void 0===this._$AM&&(this._$Cg=t,null===(i=this._$AP)||void 0===i||i.call(this,t))}}class lit_html_S{constructor(t,i,s,e,o){this.type=1,this._$AH=w,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=w}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=P(this,t,i,0),n=!lit_html_r(t)||t!==this._$AH&&t!==b,n&&(this._$AH=t);else{const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=P(this,e[s+l],i,l),h===b&&(h=this._$AH[l]),n||(n=!lit_html_r(h)||h!==this._$AH[l]),h===w?t=w:t!==w&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h}n&&!e&&this.C(t)}C(t){t===w?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"")}}class M extends lit_html_S{constructor(){super(...arguments),this.type=3}C(t){this.element[this.name]=t===w?void 0:t}}const k=lit_html_i?lit_html_i.emptyScript:"";class H extends lit_html_S{constructor(){super(...arguments),this.type=4}C(t){t&&t!==w?this.element.setAttribute(this.name,k):this.element.removeAttribute(this.name)}}class I extends lit_html_S{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5}_$AI(t,i=this){var s;if((t=null!==(s=P(this,t,i,0))&&void 0!==s?s:w)===b)return;const e=this._$AH,o=t===w&&e!==w||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==w&&(e===w||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t)}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s}get _$AU(){return this._$AM._$AU}_$AI(t){P(this,t)}}const R={L:"$lit$",P:lit_html_e,V:lit_html_o,I:1,N:C,R:V,j:u,D:P,H:N,F:lit_html_S,O:H,W:I,B:M,Z:L},z=window.litHtmlPolyfillSupport;null==z||z(E,N),(null!==(lit_html_t=globalThis.litHtmlVersions)&&void 0!==lit_html_t?lit_html_t:globalThis.litHtmlVersions=[]).push("2.2.3");
//# sourceMappingURL=lit-html.js.map

// CONCATENATED MODULE: ./node_modules/lit-element/lit-element.js

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var lit_element_l,lit_element_o;const lit_element_r=reactive_element_a;class lit_element_s extends reactive_element_a{constructor(){super(...arguments),this.renderOptions={host:this},this._$Dt=void 0}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Dt=lit_html_x(i,this.renderRoot,this.renderOptions)}connectedCallback(){var t;super.connectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!0)}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!1)}render(){return b}}lit_element_s.finalized=!0,lit_element_s._$litElement$=!0,null===(lit_element_l=globalThis.litElementHydrateSupport)||void 0===lit_element_l||lit_element_l.call(globalThis,{LitElement:lit_element_s});const lit_element_n=globalThis.litElementPolyfillSupport;null==lit_element_n||lit_element_n({LitElement:lit_element_s});const lit_element_h={_$AK:(t,e,i)=>{t._$AK(e,i)},_$AL:t=>t._$AL};(null!==(lit_element_o=globalThis.litElementVersions)&&void 0!==lit_element_o?lit_element_o:globalThis.litElementVersions=[]).push("3.2.0");
//# sourceMappingURL=lit-element.js.map

// CONCATENATED MODULE: ./node_modules/lit/index.js

//# sourceMappingURL=index.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/decorators/custom-element.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const custom_element_n=n=>e=>"function"==typeof e?((n,e)=>(window.customElements.define(n,e),e))(n,e):((n,e)=>{const{kind:t,elements:i}=e;return{kind:t,elements:i,finisher(e){window.customElements.define(n,e)}}})(n,e);
//# sourceMappingURL=custom-element.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/decorators/property.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const property_i=(i,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i)}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:e.key,initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this))},finisher(n){n.createProperty(e.key,i)}};function property_e(e){return(n,t)=>void 0!==t?((i,e,n)=>{e.constructor.createProperty(n,i)})(e,n,t):property_i(e,n)}
//# sourceMappingURL=property.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/decorators/state.js

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function state_t(t){return property_e({...t,state:!0})}
//# sourceMappingURL=state.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/decorators/base.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const base_e=(e,t,o)=>{Object.defineProperty(t,o,e)},base_t=(e,t)=>({kind:"method",placement:"prototype",key:t.key,descriptor:e}),base_o=({finisher:e,descriptor:t})=>(o,n)=>{var r;if(void 0===n){const n=null!==(r=o.originalKey)&&void 0!==r?r:o.key,i=null!=t?{kind:"method",placement:"prototype",key:n,descriptor:t(o.key)}:{...o,key:n};return null!=e&&(i.finisher=function(t){e(t,n)}),i}{const r=o.constructor;void 0!==t&&Object.defineProperty(o,n,t(n)),null==e||e(r,n)}};
//# sourceMappingURL=base.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/decorators/event-options.js

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function event_options_e(e){return base_o({finisher:(r,t)=>{Object.assign(r.prototype[t],e)}})}
//# sourceMappingURL=event-options.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/decorators/query.js

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function query_i(i,n){return base_o({descriptor:o=>{const t={get(){var o,n;return null!==(n=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==n?n:null},enumerable:!0,configurable:!0};if(n){const n="symbol"==typeof o?Symbol():"__"+o;t.get=function(){var o,t;return void 0===this[n]&&(this[n]=null!==(t=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==t?t:null),this[n]}}return t}})}
//# sourceMappingURL=query.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/decorators/query-all.js

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function query_all_e(e){return base_o({descriptor:r=>({get(){var r,o;return null!==(o=null===(r=this.renderRoot)||void 0===r?void 0:r.querySelectorAll(e))&&void 0!==o?o:[]},enumerable:!0,configurable:!0})})}
//# sourceMappingURL=query-all.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/decorators/query-async.js

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function query_async_e(e){return base_o({descriptor:r=>({async get(){var r;return await this.updateComplete,null===(r=this.renderRoot)||void 0===r?void 0:r.querySelector(e)},enumerable:!0,configurable:!0})})}
//# sourceMappingURL=query-async.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/decorators/query-assigned-elements.js

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var query_assigned_elements_n;const query_assigned_elements_e=null!=(null===(query_assigned_elements_n=window.HTMLSlotElement)||void 0===query_assigned_elements_n?void 0:query_assigned_elements_n.prototype.assignedElements)?(o,n)=>o.assignedElements(n):(o,n)=>o.assignedNodes(n).filter((o=>o.nodeType===Node.ELEMENT_NODE));function query_assigned_elements_l(n){const{slot:l,selector:t}=null!=n?n:{};return base_o({descriptor:o=>({get(){var o;const r="slot"+(l?`[name=${l}]`:":not([name])"),i=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(r),s=null!=i?query_assigned_elements_e(i,n):[];return t?s.filter((o=>o.matches(t))):s},enumerable:!0,configurable:!0})})}
//# sourceMappingURL=query-assigned-elements.js.map

// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function query_assigned_nodes_o(o,n,r){let l,s=o;return"object"==typeof o?(s=o.slot,l=o):l={flatten:n},r?query_assigned_elements_l({slot:s,flatten:n,selector:r}):base_o({descriptor:e=>({get(){var e,t;const o="slot"+(s?`[name=${s}]`:":not([name])"),n=null===(e=this.renderRoot)||void 0===e?void 0:e.querySelector(o);return null!==(t=null==n?void 0:n.assignedNodes(l))&&void 0!==t?t:[]},enumerable:!0,configurable:!0})})}
//# sourceMappingURL=query-assigned-nodes.js.map

// CONCATENATED MODULE: ./node_modules/lit/decorators.js

//# sourceMappingURL=decorators.js.map

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/ErrorMessage.js

const ErrorMessage = ({ title, children }) => $ `
  <div class="error-background">
    <div class="error-container">
      <span class="error-title"
        ><span class="error-badge">Error</span>${title}</span
      >
      <span class="error-description">${children}</span>
    </div>
  </div>
`;
const ErrorMessage_styles = css_tag_r `
  .error-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;

    background: var(--error-bg);
    color: var(--error-fg);
  }

  .error-container {
    max-width: 800px;
    margin: auto;
    padding: 1em;
  }

  .error-badge {
    display: inline-block;
    font-size: 0.8em;
    padding: 0.2em 0.5em;
    margin-inline-end: 0.5em;

    background: var(--error-color);
    border-radius: 2px;
    color: var(--error-bg);
    text-transform: uppercase;
  }

  .error-title {
    display: block;
    font-size: 1.2em;

    font-weight: bold;
    text-transform: capitalize;
  }

  .error-description {
    display: block;
    margin-block-start: 1em;
  }
`;

// CONCATENATED MODULE: ./node_modules/lit-html/directive.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const directive_t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},directive_e=t=>(...e)=>({_$litDirective$:t,values:e});class directive_i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}
//# sourceMappingURL=directive.js.map

// CONCATENATED MODULE: ./node_modules/lit-html/directives/style-map.js

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const style_map_i=directive_e(class extends directive_i{constructor(t){var e;if(super(t),t.type!==directive_t.ATTRIBUTE||"style"!==t.name||(null===(e=t.strings)||void 0===e?void 0:e.length)>2)throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.")}render(t){return Object.keys(t).reduce(((e,r)=>{const s=t[r];return null==s?e:e+`${r=r.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g,"-$&").toLowerCase()}:${s};`}),"")}update(e,[r]){const{style:s}=e.element;if(void 0===this.ct){this.ct=new Set;for(const t in r)this.ct.add(t);return this.render(r)}this.ct.forEach((t=>{null==r[t]&&(this.ct.delete(t),t.includes("-")?s.removeProperty(t):s[t]="")}));for(const t in r){const e=r[t];null!=e&&(this.ct.add(t),t.includes("-")?s.setProperty(t,e):s[t]=e)}return b}});
//# sourceMappingURL=style-map.js.map

// CONCATENATED MODULE: ./node_modules/lit/directives/style-map.js

//# sourceMappingURL=style-map.js.map

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/utils.js
function absRect(rect) {
    return {
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height,
        left: rect.x,
    };
}
function getDistanceGuides(selected, compared) {
    const a = absRect(selected);
    const b = absRect(compared);
    const isYIntersecting = !(a.top > b.bottom || a.bottom < b.top);
    const isXIntersecting = !(a.left > b.right || a.right < b.left);
    // Rects are intersecting.
    if (isXIntersecting && isYIntersecting) {
        // Center of intersecting region.
        const intersectCenter = {
            x: (Math.max(a.left, b.left) + Math.min(a.right, b.right)) / 2,
            y: (Math.max(a.top, b.top) + Math.min(a.bottom, b.bottom)) / 2,
        };
        return [
            {
                points: [
                    { x: a.left, y: intersectCenter.y },
                    { x: b.left, y: intersectCenter.y },
                ],
            },
            {
                points: [
                    {
                        x: a.right,
                        y: intersectCenter.y,
                    },
                    { x: b.right, y: intersectCenter.y },
                ],
            },
            {
                points: [
                    { y: a.top, x: intersectCenter.x },
                    { y: b.top, x: intersectCenter.x },
                ],
            },
            {
                points: [
                    {
                        y: a.bottom,
                        x: intersectCenter.x,
                    },
                    { y: b.bottom, x: intersectCenter.x },
                ],
            },
        ];
    }
    const isALeft = a.left > b.right;
    const isABelow = a.top > b.bottom;
    const selectedCenter = {
        x: selected.x + selected.width / 2,
        y: selected.y + selected.height / 2,
    };
    const guides = [
        !isXIntersecting
            ? {
                points: [
                    { x: isALeft ? a.left : a.right, y: selectedCenter.y },
                    { x: isALeft ? b.right : b.left, y: selectedCenter.y },
                ],
                bisector: !isYIntersecting
                    ? [
                        { x: isALeft ? b.right : b.left, y: selectedCenter.y },
                        {
                            x: isALeft ? b.right : b.left,
                            y: isABelow ? b.bottom : b.top,
                        },
                    ]
                    : void 0,
            }
            : null,
        !isYIntersecting
            ? {
                points: [
                    { y: isABelow ? a.top : a.bottom, x: selectedCenter.x },
                    { y: isABelow ? b.bottom : b.top, x: selectedCenter.x },
                ],
                bisector: !isXIntersecting
                    ? [
                        { y: isABelow ? b.bottom : b.top, x: selectedCenter.x },
                        {
                            y: isABelow ? b.bottom : b.top,
                            x: isALeft ? b.right : b.left,
                        },
                    ]
                    : void 0,
            }
            : null,
    ];
    return guides.filter((x) => !!x);
}
/**
 * x.xxxxx... -> x.xx
 */
function round(n) {
    return Math.round(n * 100) / 100;
}
function extendStyles(left, right) {
    return [...stylesToArray(left), ...stylesToArray(right)];
}
function stylesToArray(styles) {
    if (!styles) {
        return [];
    }
    if (styles instanceof Array) {
        return styles;
    }
    return [styles];
}

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/NodeSelectableMixin.js
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

const NodeSelectableMixin = (superClass) => {
    class NodeSelectable extends superClass {
        constructor(...args) {
            super(...args);
            this.selectedNode = null;
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has("selectedNode")) {
                this.dispatchEvent(new CustomEvent("nodeselect", {
                    detail: {
                        selectedNode: this.selectedNode,
                    },
                }));
            }
        }
    }
    __decorate([
        property_e({
            attribute: false,
        })
    ], NodeSelectable.prototype, "selectedNode", void 0);
    return NodeSelectable;
};

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/TouchGestureMixin.js
function shouldSkipEvent(ev) {
    return ev.touches.length === 0 || ev.touches.length > 2;
}
function getDistance(a, b) {
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
const TouchGestureMixin = (superClass) => class CTouchGesture extends superClass {
    constructor(...args) {
        super(...args);
        this.previousTouches = null;
        this.addEventListener("touchstart", (ev) => {
            if (shouldSkipEvent(ev)) {
                return;
            }
            ev.preventDefault();
            this.previousTouches = ev.touches;
        });
        this.addEventListener("touchend", (ev) => {
            if (shouldSkipEvent(ev)) {
                return;
            }
            ev.preventDefault();
            this.previousTouches = null;
        });
        this.addEventListener("touchcancel", (ev) => {
            if (shouldSkipEvent(ev)) {
                return;
            }
            ev.preventDefault();
            this.previousTouches = null;
        });
        this.addEventListener("touchmove", (ev) => {
            if (shouldSkipEvent(ev)) {
                return;
            }
            const previousTouches = Array.from(this.previousTouches || []);
            const currentTouches = Array.from(ev.touches);
            this.previousTouches = ev.touches;
            // When one or more than one of touch input sources differs, skip processing.
            if (currentTouches.length !== previousTouches.length ||
                !currentTouches.every((t) => previousTouches.some((pt) => pt.identifier === t.identifier))) {
                return;
            }
            // Pan
            if (currentTouches.length === 1) {
                this.onTouchPan({
                    x: currentTouches[0].pageX - previousTouches[0].pageX,
                    y: currentTouches[0].pageY - previousTouches[0].pageY,
                });
                return;
            }
            // Pinch
            this.onTouchPinch(getDistance({
                x: currentTouches[0].pageX,
                y: currentTouches[0].pageY,
            }, {
                x: previousTouches[0].pageX,
                y: previousTouches[0].pageY,
            }));
            return;
        });
    }
    get isTouching() {
        return !!(this.previousTouches && this.previousTouches.length > 0);
    }
    onTouchPan(delta) { }
    onTouchPinch(delta) { }
};

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/PositionedMixin.js
var PositionedMixin_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};


const PositionedMixin = (superClass) => {
    var _isDragModeOn, _movePanel, _keyDown, _keyUp, _listenToKeyboardEvents;
    class Positioned extends TouchGestureMixin(superClass) {
        constructor(...args) {
            super(...args);
            this.panX = 0;
            this.panY = 0;
            this.scale = 1;
            this.zoomSpeed = 500;
            this.panSpeed = 500;
            _isDragModeOn.set(this, false);
            _movePanel.set(this, (shiftX, shiftY) => {
                this.panX += shiftX / this.scale / window.devicePixelRatio;
                this.panY += shiftY / this.scale / window.devicePixelRatio;
            });
            // Enable drag mode when holding the spacebar
            _keyDown.set(this, (event) => {
                if (event.code === "Space" && !__classPrivateFieldGet(this, _isDragModeOn)) {
                    __classPrivateFieldSet(this, _isDragModeOn, true);
                    document.body.style.cursor = "grab";
                }
            });
            // Disable drag mode when space lets the spacebar go
            _keyUp.set(this, (event) => {
                if (event.code === "Space" && __classPrivateFieldGet(this, _isDragModeOn)) {
                    __classPrivateFieldSet(this, _isDragModeOn, false);
                    document.body.style.cursor = "auto";
                }
            });
            _listenToKeyboardEvents.set(this, () => {
                document.addEventListener("keyup", __classPrivateFieldGet(this, _keyUp));
                document.addEventListener("keydown", __classPrivateFieldGet(this, _keyDown));
            });
            this.addEventListener("wheel", (ev) => {
                if (!this.isMovable)
                    return;
                ev.preventDefault();
                if (ev.ctrlKey) {
                    // Performs zoom when ctrl key is pressed.
                    let { deltaY } = ev;
                    if (ev.deltaMode === 1) {
                        // Firefox quirk
                        deltaY *= 15;
                    }
                    const prevScale = this.scale;
                    this.scale *= 1 - deltaY / ((1000 - this.zoomSpeed) * 0.5);
                    // Performs pan to archive "zoom at the point" behavior (I don't know how to call it).
                    const offsetX = ev.offsetX - this.offsetWidth / 2;
                    const offsetY = ev.offsetY - this.offsetHeight / 2;
                    this.panX += offsetX / this.scale - offsetX / prevScale;
                    this.panY += offsetY / this.scale - offsetY / prevScale;
                }
                else {
                    // Performs pan otherwise (to be close to native behavior)
                    // Adjusting panSpeed in order to make panSpeed=500 to match to the Figma's one.
                    const speed = this.panSpeed * 0.002;
                    this.panX -= (ev.deltaX * speed) / this.scale;
                    this.panY -= (ev.deltaY * speed) / this.scale;
                }
            }, 
            // This component prevents every native wheel behavior on it.
            { passive: false });
            // Base scale for Safari's GestureEvents
            let gestureStartScale = 1;
            this.addEventListener("gesturestart", (ev) => {
                ev.preventDefault();
                gestureStartScale = this.scale;
            });
            this.addEventListener("gesturechange", (_ev) => {
                const ev = _ev;
                ev.preventDefault();
                // We can't perform zoom-at-the-point due to lack of offsetX/Y in GestureEvent
                this.scale = gestureStartScale * ev.scale;
            });
            this.addEventListener("pointermove", (ev) => {
                // Performs pan only when middle buttons is pressed.
                //
                // 4 ... Auxiliary button (usually the mouse wheel button or middle button)
                // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
                if (!(ev.buttons & 4))
                    return;
                ev.preventDefault();
                // Moving amount of middle button+pointer move panning should matches to the actual
                // pointer travel distance. Since translate goes after scaling, we need to scale
                // delta too.
                __classPrivateFieldGet(this, _movePanel).call(this, ev.movementX, ev.movementY);
            });
            // Listen to keyboard events to enable dragging when Space is pressed, just like in Figma
            __classPrivateFieldGet(this, _listenToKeyboardEvents).call(this);
            /** @private */
            this.onmousedown = () => {
                if (__classPrivateFieldGet(this, _isDragModeOn)) {
                    document.body.style.cursor = "grabbing";
                    this.onmousemove = ({ movementX, movementY }) => {
                        __classPrivateFieldGet(this, _movePanel).call(this, movementX, movementY);
                    };
                    // cleanup unnecessary listeners when user stops dragging
                    this.onmouseup = () => {
                        document.body.style.cursor = "grab";
                        this.onmousemove = null;
                        this.onmouseup = null;
                    };
                }
            };
        }
        get isMovable() {
            return true;
        }
        get canvasTransform() {
            return [
                `scale(${this.scale})`,
                `translate(${this.panX}px, ${this.panY}px)`,
            ];
        }
        disconnectedCallback() {
            document.removeEventListener("keyup", __classPrivateFieldGet(this, _keyUp));
            document.removeEventListener("keydown", __classPrivateFieldGet(this, _keyDown));
            super.disconnectedCallback();
        }
        // Dispatch events when the position-related value changes.
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has("scale")) {
                this.dispatchEvent(new CustomEvent("scalechange", {
                    detail: {
                        scale: this.scale,
                    },
                }));
            }
            if (changedProperties.has("panX") || changedProperties.has("panY")) {
                this.dispatchEvent(new CustomEvent("positionchange", {
                    detail: {
                        x: this.panX,
                        y: this.panY,
                    },
                }));
            }
        }
        onTouchPan(delta) {
            this.panX += delta.x / this.scale;
            this.panY += delta.y / this.scale;
        }
        onTouchPinch(delta) {
            // TODO: Remove this no-brainer magic number
            this.scale *= 1 - delta / 1000;
        }
    }
    _isDragModeOn = new WeakMap(), _movePanel = new WeakMap(), _keyDown = new WeakMap(), _keyUp = new WeakMap(), _listenToKeyboardEvents = new WeakMap();
    PositionedMixin_decorate([
        property_e({
            attribute: false,
        })
    ], Positioned.prototype, "panX", void 0);
    PositionedMixin_decorate([
        property_e({
            attribute: false,
        })
    ], Positioned.prototype, "panY", void 0);
    PositionedMixin_decorate([
        property_e({
            attribute: false,
        })
    ], Positioned.prototype, "scale", void 0);
    PositionedMixin_decorate([
        property_e({
            type: Number,
            attribute: "zoom-speed",
        })
    ], Positioned.prototype, "zoomSpeed", void 0);
    PositionedMixin_decorate([
        property_e({
            type: Number,
            attribute: "pan-speed",
        })
    ], Positioned.prototype, "panSpeed", void 0);
    return Positioned;
};

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/DistanceGuide.js



const Line = ({ guide, reverseScale }) => {
    const xLength = Math.abs(guide.points[0].x - guide.points[1].x);
    const yLength = Math.abs(guide.points[0].y - guide.points[1].y);
    if (xLength === 0 && yLength === 0) {
        return null;
    }
    return lit_html_y `
    <line
      class="distance-line"
      x1=${guide.points[0].x}
      y1=${guide.points[0].y}
      x2=${guide.points[1].x}
      y2=${guide.points[1].y}
    />

    ${guide.bisector &&
        lit_html_y `
        <line
          class="distance-line"
          x1=${guide.bisector[0].x}
          y1=${guide.bisector[0].y}
          x2=${guide.bisector[1].x}
          y2=${guide.bisector[1].y}
          style=${style_map_i({
            strokeDasharray: `${4 * reverseScale}`,
        })}
          shape-rendering="geometricPrecision"
          fill="none"
        />
      `}
  `;
};
const Tooltip = ({ guide, reverseScale, fontSize }) => {
    const xLength = Math.abs(guide.points[0].x - guide.points[1].x);
    const yLength = Math.abs(guide.points[0].y - guide.points[1].y);
    if (xLength === 0 && yLength === 0) {
        return null;
    }
    const text = round(Math.max(xLength, yLength)).toString(10);
    // Decreases font width because every text is a number (narrow).
    // We can measure the correct width with getComputedTextLength method on
    // <text> element, but it needs access to DOM or creating an element each
    // render cycle, both have performance costs.
    const width = text.length * fontSize * 0.5;
    const startMargin = fontSize * 0.25;
    const vPadding = fontSize * 0.25;
    const hPadding = fontSize * 0.5;
    const x = xLength > yLength
        ? (guide.points[0].x + guide.points[1].x) / 2 - width / 2
        : guide.points[0].x;
    const y = xLength > yLength
        ? guide.points[0].y
        : (guide.points[0].y + guide.points[1].y) / 2 - fontSize / 2;
    const transform = [
        `scale(${reverseScale})`,
        xLength > yLength
            ? `translate(0, ${startMargin + vPadding})`
            : `translate(${startMargin + hPadding}, 0)`,
    ].join(" ");
    const cx = x + width / 2;
    const cy = y + fontSize / 2;
    const transformOrigin = xLength > yLength ? `${cx} ${y}` : `${x} ${cy}`;
    return lit_html_y `
    <g class="distance-tooltip">
      <rect
        x=${x - hPadding}
        y=${y - vPadding}
        rx="2"
        width=${width + hPadding * 2}
        height=${fontSize + vPadding * 2}
        transform=${transform}
        transform-origin=${transformOrigin}
        stroke="none"
      />

      <text
        x=${cx}
        y=${y + fontSize - vPadding / 2}
        text-anchor="middle"
        transform=${transform}
        transform-origin=${transformOrigin}
        stroke="none"
        fill="white"
        style="font-size: ${fontSize}px"
      >
        ${text}
      </text>
    </g>
  `;
};
const guidesCache = new Map();
const Guides = ({ node, distanceTo, reverseScale, fontSize, }) => {
    const combinedId = node.id + "\n" + distanceTo.id;
    let guides = guidesCache.get(combinedId);
    if (!guides) {
        guides = getDistanceGuides(node.absoluteBoundingBox, distanceTo.absoluteBoundingBox);
        guidesCache.set(combinedId, guides);
    }
    return [
        ...guides.map((guide) => Line({ guide, reverseScale })),
        ...guides.map((guide) => Tooltip({ guide, reverseScale, fontSize })),
    ];
};
const DistanceGuide_styles = css_tag_r `
  .distance-line {
    shape-rendering: geometricPrecision;
    fill: none;
    opacity: 0;
  }

  .distance-tooltip {
    opacity: 0;
  }

  .guide:hover ~ .distance-line,
  .guide:hover ~ .distance-tooltip {
    opacity: 1;
  }
`;

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/Icons.js

const CloseIcon = ({ onClick = () => { } }) => lit_html_y `
  <svg @click=${onClick} title="close icon" width="14" height="14" viewBox="0 0 20 20" fill="none">
    <path d="M1 19L19 1M19 19L1 1" stroke="#B3B3B3" stroke-width="2"/>
  </svg>
`;
const CopyIcon = ({ onClick = () => { } }) => lit_html_y `
  <svg @click=${onClick} title="copy icon" width="14" height="14" viewBox="0 0 30 30" fill="none">
  <path d="M21 25.5C21 24.9477 20.5523 24.5 20 24.5C19.4477 24.5 19 24.9477 19 25.5H21ZM13 2H25V0H13V2ZM28 5V21H30V5H28ZM25 24H13V26H25V24ZM10 21V5H8V21H10ZM13 24C11.3431 24 10 22.6569 10 21H8C8 23.7614 10.2386 26 13 26V24ZM28 21C28 22.6569 26.6569 24 25 24V26C27.7614 26 30 23.7614 30 21H28ZM25 2C26.6569 2 28 3.34315 28 5H30C30 2.23858 27.7614 0 25 0V2ZM13 0C10.2386 0 8 2.23858 8 5H10C10 3.34315 11.3431 2 13 2V0ZM16.5 28H5V30H16.5V28ZM2 25V10H0V25H2ZM5 28C3.34315 28 2 26.6569 2 25H0C0 27.7614 2.23858 30 5 30V28ZM5 7H8V5H5V7ZM2 10C2 8.34315 3.34315 7 5 7V5C2.23858 5 0 7.23858 0 10H2ZM16.5 30C18.9853 30 21 27.9853 21 25.5H19C19 26.8807 17.8807 28 16.5 28V30Z" fill="#B3B3B3"/>
</svg>
`;
const HorizontalPaddingIcon = () => lit_html_y `
  <svg title="horizontal padding" width="14" height="14" viewBox="0 0 29 28" fill="none">
    <rect x="7" y="8" width="14" height="14" stroke="#B3B3B3" stroke-width="2"/>
    <path d="M27 1V28" stroke="#B3B3B3" stroke-width="2"/>
    <path d="M1 0V28" stroke="#B3B3B3" stroke-width="2"/>
  </svg>
`;
const VerticalPaddingIcon = () => lit_html_y `
  <svg title="vertical padding" width="14" height="14" viewBox="0 0 29 28" fill="none" xmlns="http://www.w3.org/2000/svg">
    <rect x="8" y="21" width="14" height="14" transform="rotate(-90 8 21)" stroke="#B3B3B3" stroke-width="2"/>
    <path d="M1 1L28 0.999999" stroke="#B3B3B3" stroke-width="2"/>
    <path d="M0 27L28 27" stroke="#B3B3B3" stroke-width="2"/>
  </svg>
`;
const FigmaIcon = () => lit_html_y `
  <svg title="figma logo" width="11" height="16" viewBox="0 0 12 17" xmlns="http://www.w3.org/2000/svg">
    <path
      d="M5.5 1.5h-2c-1.105 0-2 .895-2 2 0 1.105.895 2 2 2h2v-4zm-5 2c0 1.043.533 1.963 1.341 2.5C1.033 6.537.5 7.457.5 8.5c0 1.043.533 1.963 1.341 2.5C1.033 11.537.5 12.457.5 13.5c0 1.657 1.343 3 3 3 1.657 0 3-1.343 3-3V10.736c.53.475 1.232.764 2 .764 1.657 0 3-1.343 3-3 0-1.043-.533-1.963-1.341-2.5.808-.537 1.341-1.457 1.341-2.5 0-1.657-1.343-3-3-3h-5c-1.657 0-3 1.343-3 3zm1 5c0-1.105.895-2 2-2h2v4h-2c-1.105 0-2-.895-2-2zm0 5c0-1.105.895-2 2-2h2v2c0 1.105-.895 2-2 2-1.105 0-2-.895-2-2zm7-3c-1.105 0-2-.895-2-2 0-1.105.895-2 2-2 1.105 0 2 .895 2 2 0 1.105-.895 2-2 2zm0-5h-2v-4h2c1.105 0 2 .895 2 2 0 1.105-.895 2-2 2z"
      fill-rule="evenodd"
      fill-opacity="1"
      fill="#000"
      stroke="none"
    ></path>
  </svg>
`;

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/InspectorView/utils.js
const extractColorStyle = (color) => {
    if (color.a === 0) {
        return "transparent";
    }
    else if (color.a < 1) {
        return `rgba(${rgbToIntArray(color).join(", ")}, ${color.a.toFixed(2)})`;
    }
    else {
        return rgbToHex(color);
    }
};
const extractGradientColorStyle = (color) => {
    return new Gradient(color).cssColor;
};
class Gradient {
    constructor(data) {
        this.gradientHandles = {
            start: data.gradientHandlePositions[0],
            end: data.gradientHandlePositions[1],
        };
        this.colors = data.gradientStops;
        this.colorObjects = this.createColorObjects(this.colors);
        this.angle = this.calculateAngle(this.gradientHandles.start, this.gradientHandles.end);
    }
    get cssGradientArray() {
        return this.colorObjects.map((color, index) => {
            const position = this.floatToPercent(this.colors[index].position);
            return color + " " + position;
        });
    }
    get cssColor() {
        const cssGradientArray = this.cssGradientArray;
        cssGradientArray.unshift(this.angle + "deg");
        return `linear-gradient(${cssGradientArray.join(", ")})`;
    }
    createColorObjects(colors) {
        return colors.map(({ color }) => extractColorStyle(color));
    }
    floatToPercent(value) {
        return (value *= 100).toFixed(0) + "%";
    }
    calculateAngle(startHandle, endHandle) {
        const radians = Math.atan(this.calculateGradient(startHandle, endHandle));
        return parseInt(this.radToDeg(radians).toFixed(1));
    }
    calculateGradient(startHandle, endHandle) {
        return ((endHandle.y - startHandle.y) / (endHandle.x - startHandle.x)) * -1;
    }
    radToDeg(radian) {
        return (180 * radian) / Math.PI;
    }
}
class NodeStyles {
    constructor(node) {
        var _a, _b, _c;
        this.hasPadding = false;
        this.height = `${Math.trunc(node.absoluteBoundingBox.height)}px`;
        this.width = `${Math.trunc(node.absoluteBoundingBox.width)}px`;
        // paddings
        if (node.horizontalPadding || node.verticalPadding) {
            this.hasPadding = true;
            this.horizontalPadding = `${node.horizontalPadding}px`;
            this.verticalPadding = `${node.verticalPadding}px`;
        }
        // font styles
        if (node.style) {
            this.fontFamily = node.style.fontFamily;
            this.fontPostScriptName = (_a = node.style.fontPostScriptName) === null || _a === void 0 ? void 0 : _a.replace("-", " ");
            this.fontWeight = node.style.fontWeight;
            this.fontSize = `${Math.ceil(node.style.fontSize)}px`;
            this.lineHeight = `${Math.trunc(node.style.lineHeightPx)}px`;
        }
        // border radii
        if (node.rectangleCornerRadii) {
            this.borderRadius =
                node.rectangleCornerRadii.filter((radius) => radius === node.cornerRadius).length < 4
                    ? `${node.rectangleCornerRadii.join("px ")}px`
                    : `${node.cornerRadius}px`;
        }
        // colors, background, fill
        if (node.backgroundColor || node.backgroundColor) {
            const color = node.backgroundColor || ((_b = node.background) === null || _b === void 0 ? void 0 : _b[0].color);
            this.background = extractColorStyle(color);
        }
        const fillColor = (_c = node.fills) === null || _c === void 0 ? void 0 : _c[0];
        if (fillColor && fillColor.visible !== false) {
            if (node.type === "TEXT") {
                this.color = extractColorStyle(fillColor.color);
            }
            else if (fillColor.type.includes("GRADIENT")) {
                this.backgroundImage = extractGradientColorStyle(fillColor);
            }
            else if (fillColor.type === "SOLID") {
                this.background = extractColorStyle(fillColor.color);
            }
        }
        // borders
        if (node.strokes && node.strokes.length > 0) {
            this.borderColor = extractColorStyle(node.strokes[0].color);
            this.border = `${node.strokeWeight}px solid ${this.borderColor}`;
        }
        // box-shadow
        if (node.effects && node.effects.length > 0) {
            const { offset, radius, color } = node.effects[0];
            this.boxShadowColor = extractColorStyle(color);
            this.boxShadow = `${(offset === null || offset === void 0 ? void 0 : offset.x) || 0}px ${(offset === null || offset === void 0 ? void 0 : offset.y) || 0}px 0 ${radius} ${this.boxShadowColor}`;
        }
    }
    getStyles() {
        return [
            this.height && { property: "height", value: this.height },
            this.width && { property: "width", value: this.width },
            this.fontFamily && { property: "font-family", value: this.fontFamily },
            this.fontSize && { property: "font-size", value: this.fontSize },
            this.fontWeight && { property: "font-weight", value: this.fontWeight },
            this.lineHeight && { property: "line-height", value: this.lineHeight },
            this.borderRadius && {
                property: "border-radius",
                value: this.borderRadius,
            },
            this.backgroundImage && {
                property: "background-image",
                value: this.backgroundImage,
            },
            this.boxShadow && {
                property: "box-shadow",
                value: this.boxShadow,
                color: this.boxShadowColor,
            },
            this.border && {
                property: "border",
                value: this.border,
                color: this.borderColor,
            },
            this.background && {
                property: "background",
                value: this.background,
                color: this.background,
            },
            this.color && { property: "color", value: this.color, color: this.color },
        ].filter(Boolean);
    }
    getStyleSheet() {
        return this.getStyles().map(getStyleRule).join("\n");
    }
}
const rgbToIntArray = (color) => [
    Math.trunc(255 * color.r),
    Math.trunc(255 * color.g),
    Math.trunc(255 * color.b),
];
const rgbToHex = (color) => {
    const [r, g, b] = rgbToIntArray(color);
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
};
const getStyleRule = ({ property, value }) => `${property}: ${value};`;

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/InspectorView/InspectorView.js
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const copy = (text) => __awaiter(void 0, void 0, void 0, function* () {
    yield navigator.clipboard.writeText(text);
});
const View = ({ node, onClose }) => {
    if (!node) {
        return null;
    }
    const nodeStyles = new NodeStyles(node);
    // In order to disable canvas interactions (e.g. pan, click to
    // deselect), we need to cancel JavaScript event propagation
    // on the root element.
    const stopPropagation = (ev) => ev.stopPropagation();
    return $ `
    <div
      class="inspector-view"
      @click=${stopPropagation}
      @wheel=${stopPropagation}
      @keydown=${stopPropagation}
      @keyup=${stopPropagation}
      @pointermove=${stopPropagation}
    >
      <div class="inspector-section selectable-content">
        <div class="title-section">
          <h4>${node.name}</h4>
          ${CloseIcon({ onClick: onClose })}
        </div>
        <div class="properties-overview">
          <div class="title-section">
            <p class="inspector-property">
              <span>W: </span>${nodeStyles.width}
            </p>
            <p class="inspector-property" style="margin-left: 16px;">
              <span>H: </span>${nodeStyles.height}
            </p>
          </div>
          ${nodeStyles.fontPostScriptName
        ? $ `<p class="inspector-property">
                <span>Font:</span>
                ${nodeStyles.fontPostScriptName}
              </p>`
        : null}
        </div>
      </div>
      ${nodeStyles.hasPadding
        ? $ `<div class="inspector-section">
            <h4>Layout</h4>
            ${nodeStyles.horizontalPadding &&
            $ `<p class="inspector-property">
              ${HorizontalPaddingIcon()} ${nodeStyles.horizontalPadding}
            </p>`}
            ${nodeStyles.verticalPadding &&
            $ `<p class="inspector-property">
              ${VerticalPaddingIcon()} ${nodeStyles.verticalPadding}
            </p>`}
          </div>`
        : null}
      ${node.characters
        ? $ `<div class="inspector-section">
            <div class="title-section">
              <h4>Content</h4>
              ${CopyIcon({ onClick: () => copy(node.characters) })}
            </div>
            <p class="node-content code-section selectable-content">
              ${node.characters}
            </p>
          </div>`
        : null}
      ${StylesSection(nodeStyles)}
    </div>
  `;
};
const StylesSection = (nodeStyles) => {
    const onClick = () => copy(nodeStyles.getStyleSheet());
    const styles = nodeStyles.getStyles();
    return $ `<div class="inspector-section">
    <div class="title-section style-section">
      <h4>CSS</h4>
      ${CopyIcon({ onClick })}
    </div>
    <div class="code-section selectable-content">
      ${styles.map(CSSProperty)}
    </div>
  </div>`;
};
const CSSProperty = (cssProperty) => {
    const { property, value, color } = cssProperty;
    let coloredSquare = null;
    switch (property) {
        case "background":
        case "fill":
        case "border":
        case "box-shadow":
        case "color":
            coloredSquare = $ `<span
        class="color-preview"
        style="background-color: ${color}"
      ></span>`;
            break;
        case "background-image":
            coloredSquare = $ `<span
        class="color-preview"
        style="background-image: ${value}"
      ></span>`;
            break;
    }
    return $ `<div class="css-property" @click=${() => copy(getStyleRule(cssProperty))}>
    <span>${property}:</span>${coloredSquare}<span class="css-value">${value}</span>;</span>
  </div>`;
};
const InspectorView_styles = css_tag_r `
  .inspector-view {
    height: 100%;
    width: 300px;
    position: absolute;
    right: 0;
    background: white;
    border-left: 1px solid #ccc;
    overflow-y: auto;
    z-index: calc(var(--z-index) + 2);
  }

  .inspector-view h4 {
    font-size: 16px;
    margin: 0;
  }

  .style-section {
    margin-bottom: 12px;
  }

  .title-section {
    display: flex;
    align-items: center;
  }

  .code-section {
    padding: 8px;
    background: #f3f3f3;
    font-family: monospace;
  }

  .title-section svg {
    cursor: pointer;
    margin-left: auto;
  }

  .inspector-section {
    padding: 16px;
    border-bottom: 1px solid #eee;
  }

  .properties-overview {
    font-family: monospace;
    color: #518785;
  }

  .properties-overview p span {
    color: #121212;
  }

  .inspector-property {
    display: flex;
    align-items: center;
    margin-bottom: 0;
  }

  .inspector-property span {
    color: #b3b3b3;
    margin-right: 4px;
  }

  .inspector-property svg {
    margin-right: 8px;
  }

  .css-property {
    margin: 8px;
    transition: background-color ease-in-out 100ms;
  }

  .css-property:hover {
    cursor: pointer;
    background-color: #e8e8e8;
  }

  .css-value {
    color: #518785;
    margin-left: 4px;
  }

  .color-preview {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 1px solid #ccc;
    margin-left: 4px;
    vertical-align: middle;
  }

  .selectable-content {
    cursor: text;
    user-select: text;
  }
`;

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/Node.js



const Outline = ({ node, selected = false, computedThickness, onClick, }) => {
    const { x, y, width, height } = node.absoluteBoundingBox;
    const radius = "cornerRadius" in node && node.cornerRadius
        ? {
            topLeft: node.cornerRadius,
            topRight: node.cornerRadius,
            bottomRight: node.cornerRadius,
            bottomLeft: node.cornerRadius,
        }
        : "rectangleCornerRadii" in node && node.rectangleCornerRadii
            ? {
                topLeft: node.rectangleCornerRadii[0],
                topRight: node.rectangleCornerRadii[1],
                bottomRight: node.rectangleCornerRadii[2],
                bottomLeft: node.rectangleCornerRadii[3],
            }
            : {
                topLeft: 0,
                topRight: 0,
                bottomRight: 0,
                bottomLeft: 0,
            };
    // Since SVG can't control where to draw borders (I mean you can't draw inset borders), we need to
    // shift each drawing points by the half of the border width.
    const shift = computedThickness / 2;
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
    // [M] ... Move to
    // [L] ... Line to
    // [A] ... Arc to
    // [Z] ... Close path
    const moveTo = (x, y) => `M${x},${y}`;
    const lineTo = (x, y) => `L${x},${y}`;
    const arcTo = (r, x, y) => `A${r},${r} 0 0 1 ${x},${y}`;
    const boxPath = [
        moveTo(radius.topLeft + shift, shift),
        lineTo(width - radius.topRight, shift),
        arcTo(radius.topRight - shift, width - shift, radius.topRight),
        lineTo(width - shift, height - radius.bottomRight),
        arcTo(radius.bottomRight - shift, width - radius.bottomRight, height - shift),
        lineTo(radius.bottomLeft, height - shift),
        arcTo(radius.bottomLeft - shift, shift, height - radius.bottomLeft),
        lineTo(shift, radius.topLeft),
        arcTo(radius.topLeft - shift, radius.topLeft, shift),
        "Z",
    ].join(" ");
    return lit_html_y `
    <path
      class="guide"
      d=${boxPath}
      shape-rendering="geometricPrecision"
      fill="none"
      transform="translate(${x}, ${y})"
      ?data-selected=${selected}
      @click=${onClick}
    />
  `;
};
const Node_Tooltip = ({ nodeSize: { x, y, width, height }, offsetX, offsetY, reverseScale, }) => {
    const tooltipStyle = {
        top: `${offsetY + y + height}px`,
        left: `${offsetX + x + width / 2}px`,
        transform: `translateX(-50%) scale(${reverseScale}) translateY(0.25em)`,
    };
    return $ `
    <div class="tooltip" style="${style_map_i(tooltipStyle)}">
      ${round(width)} x ${round(height)}
    </div>
  `;
};
const Node_styles = css_tag_r `
  .guide {
    /*
     * SVGs cannot be pixel perfect, especially floating values.
     * Since many platform renders them visually incorrectly (probably they
     * are following the spec), it's safe to set overflow to visible.
     * Cropped borders are hard to visible and ugly.
     */
    overflow: visible;

    pointer-events: all;

    opacity: 0;
  }
  .guide:hover {
    opacity: 1;
  }
  .guide[data-selected] {
    opacity: 1;
    stroke: var(--guide-selected-color);
  }

  .tooltip {
    position: absolute;
    padding: 0.25em 0.5em;
    font-size: var(--guide-tooltip-font-size);

    color: var(--guide-selected-tooltip-fg);
    background-color: var(--guide-selected-tooltip-bg);
    border-radius: 2px;
    pointer-events: none;
    z-index: calc(var(--z-index) + 1);

    transform-origin: top center;
  }
`;

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/Footer/utils.js
const SECOND = 1000;
const MINUTE = 60 * SECOND;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
const WEEK = 7 * DAY;
const MONTH = 30 * DAY;
const YEAR = 365 * DAY;
const intervals = [
    { gte: YEAR, divisor: YEAR, unit: "year" },
    { gte: MONTH, divisor: MONTH, unit: "month" },
    { gte: WEEK, divisor: WEEK, unit: "week" },
    { gte: DAY, divisor: DAY, unit: "day" },
    { gte: HOUR, divisor: HOUR, unit: "hour" },
    { gte: MINUTE, divisor: MINUTE, unit: "minute" },
    { gte: 30 * SECOND, divisor: SECOND, unit: "seconds" },
    { gte: 0, divisor: 1, text: "just now" },
];
const getTime = (targetDate) => {
    const date = typeof targetDate === "object"
        ? targetDate
        : new Date(targetDate);
    return date.getTime();
};
/**
 * Receives two dates to compare and returns "time ago" based on them
 * example: 4 weeks ago
 *
 * Heavily inspired by https://stackoverflow.com/a/67338038/938822
 */
const fromNow = (date, nowDate = Date.now(), rft = new Intl.RelativeTimeFormat(undefined, { numeric: "auto" })) => {
    const now = getTime(nowDate);
    const diff = now - getTime(date);
    const diffAbs = Math.abs(diff);
    for (const interval of intervals) {
        if (diffAbs >= interval.gte) {
            const x = Math.round(Math.abs(diff) / interval.divisor);
            const isInFuture = diff < 0;
            const intervalUnit = interval.unit;
            return intervalUnit
                ? rft.format(isInFuture ? x : -x, intervalUnit)
                : interval.text;
        }
    }
};

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/Footer/Footer.js



const Footer_styles = css_tag_r `
  .figma-footer {
    flex: 0;
    z-index: calc(var(--z-index) + 1);
    border-top: 1px solid #ccc;
    min-height: 48px;
    padding: 0 16px;
    text-decoration: none;
    display: flex;
    flex-direction: row;
    justify-content: start;
    align-items: center;
    background-color: #fff;
    overflow-x: auto;
    cursor: pointer;
    font-size: 12px;
    color: rgba(0, 0, 0, 0.8);
  }

  .figma-footer--icon {
    margin-right: 12px;
  }

  .figma-footer--title {
    font-weight: 600;
    margin-right: 4px;

    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .figma-footer--timestamp {
    white-space: nowrap;
    overflow: hidden;
  }
`;
const Footer = (metadata) => {
    // Do not render in case there is no metadata or a link is not passed
    if (!metadata ||
        !metadata.link ||
        metadata.link === undefined ||
        metadata.link === "undefined") {
        return null;
    }
    const { link, timestamp, fileName } = metadata;
    return $ `<a
    class="figma-footer"
    target="_blank"
    rel="noopener"
    title="Open in Figma"
    href="${link}"
  >
    <span class="figma-footer--icon"> ${FigmaIcon()} </span>
    <span class="figma-footer--title"> ${fileName} </span>
    <span
      title="Last time edited: ${new Date(timestamp).toUTCString()}"
      class="figma-footer--timestamp"
    >
      Edited ${fromNow(timestamp)}
    </span>
  </a>`;
};

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/ViewerMixin.js
var ViewerMixin_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ViewerMixin_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var ViewerMixin_classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};











const ViewerMixin = (superClass) => {
    var _canvasSize, _effectMargins, _flattenedNodes, _handleNodeClick, _getNodeById;
    class Viewer extends NodeSelectableMixin(PositionedMixin(superClass)) {
        constructor(...args) {
            super(...args);
            this.zoomMargin = 50;
            this.link = "";
            // Cached values
            _canvasSize.set(this, void 0);
            _effectMargins.set(this, void 0);
            _flattenedNodes.set(this, void 0);
            _handleNodeClick.set(this, (node) => (ev) => {
                ev.preventDefault();
                ev.stopPropagation();
                this.selectedNode = node;
            });
            _getNodeById.set(this, (id) => {
                var _a, _b;
                return (_b = (_a = ViewerMixin_classPrivateFieldGet(this, _flattenedNodes)) === null || _a === void 0 ? void 0 : _a.find((n) => n.id === id)) !== null && _b !== void 0 ? _b : null;
            });
        }
        static get styles() {
            // @ts-ignore
            const styles = super.styles;
            return extendStyles(styles, [
                css_tag_r `
          :host {
            --default-error-bg: #fff;
            --default-error-fg: #333;

            --bg: var(--figspec-viewer-bg, #e5e5e5);
            --z-index: var(--figspec-viewer-z-index, 0);
            --error-bg: var(--figspec-viewer-error-bg, var(--default-error-bg));
            --error-fg: var(--figspec-viewer-error-fg, var(--default-error-fg));
            --error-color: var(--figspec-viewer-error-color, tomato);

            --guide-thickness: var(--figspec-viewer-guide-thickness, 1.5px);
            --guide-color: var(--figspec-viewer-guide-color, tomato);
            --guide-selected-color: var(
              --figspec-viewer-guide-selected-color,
              dodgerblue
            );
            --guide-tooltip-fg: var(--figspec-viewer-guide-tooltip-fg, white);
            --guide-selected-tooltip-fg: var(
              --figspec-viewer-guide-selected-tooltip-fg,
              white
            );
            --guide-tooltip-bg: var(
              --figspec-viewer-guide-tooltip-bg,
              var(--guide-color)
            );
            --guide-selected-tooltip-bg: var(
              --figspec-viewer-guide-selected-tooltip-bg,
              var(--guide-selected-color)
            );
            --guide-tooltip-font-size: var(
              --figspec-viewer-guide-tooltip-font-size,
              12px
            );

            position: relative;
            display: block;

            background-color: var(--bg);
            user-select: none;
            overflow: hidden;
            z-index: var(--z-index);
          }

          @media (prefers-color-scheme: dark) {
            :host {
              --default-error-bg: #222;
              --default-error-fg: #fff;
            }
          }

          .spec-canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column-reverse;
          }

          .canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            flex: 1;
          }

          .rendered-image {
            position: absolute;
            top: 0;
            left: 0;
          }

          .guides {
            position: absolute;

            overflow: visible;
            stroke: var(--guide-color);
            fill: var(--guide-color);
            pointer-events: none;
            z-index: calc(var(--z-index) + 2);
          }
        `,
                Node_styles,
                ErrorMessage_styles,
                DistanceGuide_styles,
                InspectorView_styles,
                Footer_styles,
            ]);
        }
        get __images() {
            return {};
        }
        deselectNode() {
            this.selectedNode = null;
        }
        get error() {
            if (!ViewerMixin_classPrivateFieldGet(this, _canvasSize) || !ViewerMixin_classPrivateFieldGet(this, _flattenedNodes)) {
                return ErrorMessage({
                    title: "Error",
                    children: "Please call `__updateTree/1` method with a valid parameter.",
                });
            }
            return null;
        }
        render() {
            if (this.error) {
                if (this.error instanceof Error) {
                    return ErrorMessage({
                        title: this.error.name || "Error",
                        children: this.error.message,
                    });
                }
                if (typeof this.error === "string") {
                    return ErrorMessage({
                        title: "Error",
                        children: this.error,
                    });
                }
                return this.error;
            }
            const canvasSize = ViewerMixin_classPrivateFieldGet(this, _canvasSize);
            const reverseScale = 1 / this.scale;
            const guideThickness = `calc(var(--guide-thickness) * ${reverseScale})`;
            const computedGuideThickness = parseFloat(getComputedStyle(this).getPropertyValue("--guide-thickness"));
            const computedGuideTooltipFontSize = parseFloat(getComputedStyle(this).getPropertyValue("--guide-tooltip-font-size"));
            return $ `
        <div class="spec-canvas-wrapper" @click=${this.deselectNode}>
          <div
            class="canvas"
            style="
          width: ${canvasSize.width}px;
          height: ${canvasSize.height}px;

          transform: translate(-50%, -50%) ${this.canvasTransform.join(" ")}
        "
          >
            ${Object.entries(this.__images).map(([nodeId, uri]) => {
                var _a;
                const node = ViewerMixin_classPrivateFieldGet(this, _getNodeById).call(this, nodeId);
                if (!node ||
                    !("absoluteBoundingBox" in node) ||
                    !((_a = ViewerMixin_classPrivateFieldGet(this, _effectMargins)) === null || _a === void 0 ? void 0 : _a[node.id])) {
                    return null;
                }
                const margin = ViewerMixin_classPrivateFieldGet(this, _effectMargins)[node.id];
                return $ `
                <img class="rendered-image" src="${uri}"
                style=${style_map_i({
                    top: `${node.absoluteBoundingBox.y - canvasSize.y}px`,
                    left: `${node.absoluteBoundingBox.x - canvasSize.x}px`,
                    marginTop: `${-margin.top}px`,
                    marginLeft: `${-margin.left}px`,
                    width: node.absoluteBoundingBox.width +
                        margin.left +
                        margin.right +
                        "px",
                    height: node.absoluteBoundingBox.height +
                        margin.top +
                        margin.bottom +
                        "px",
                })}"
                " />
              `;
            })}
            ${this.selectedNode &&
                Node_Tooltip({
                    nodeSize: this.selectedNode.absoluteBoundingBox,
                    offsetX: -canvasSize.x,
                    offsetY: -canvasSize.y,
                    reverseScale,
                })}
            ${lit_html_y `
            <svg
              class="guides"
              viewBox="0 0 5 5"
              width="5"
              height="5"
              style=${style_map_i({
                left: `${-canvasSize.x}px`,
                top: `${-canvasSize.y}px`,
                strokeWidth: guideThickness,
            })}
            >
              ${this.selectedNode &&
                Outline({
                    node: this.selectedNode,
                    selected: true,
                    computedThickness: computedGuideThickness * reverseScale,
                })}

              ${ViewerMixin_classPrivateFieldGet(this, _flattenedNodes).map((node) => {
                var _a;
                if (node.id === ((_a = this.selectedNode) === null || _a === void 0 ? void 0 : _a.id)) {
                    return null;
                }
                return lit_html_y `
                  <g>
                    ${Outline({
                    node,
                    computedThickness: computedGuideThickness * reverseScale,
                    onClick: ViewerMixin_classPrivateFieldGet(this, _handleNodeClick).call(this, node),
                })}
                    ${this.selectedNode &&
                    Guides({
                        node,
                        distanceTo: this.selectedNode,
                        reverseScale,
                        fontSize: computedGuideTooltipFontSize,
                    })}
                  </g>
                `;
            })}
            </svg>
          `}
          </div>
          ${View({
                node: this.selectedNode,
                onClose: this.deselectNode,
            })}
          ${Footer(this.getMetadata())}
        </div>
      `;
        }
        // implemented in FileViewer/FrameViewer
        getMetadata() {
            return undefined;
        }
        connectedCallback() {
            super.connectedCallback();
            this.resetZoom();
        }
        updated(changedProperties) {
            super.updated(changedProperties);
        }
        __updateTree(node) {
            if (!(node.type === "CANVAS" ||
                node.type === "FRAME" ||
                node.type === "COMPONENT" ||
                //@ts-ignore NOTE: figma-js does not implement COMPONENT_SET type (yet?)
                node.type === "COMPONENT_SET")) {
                throw new Error("Cannot update node tree: Top level node MUST be one of CANVAS, FRAME, COMPONENT, or COMPONENT_SET");
            }
            ViewerMixin_classPrivateFieldSet(this, _canvasSize, node.type === "CANVAS" ? getCanvasSize(node) : node.absoluteBoundingBox);
            ViewerMixin_classPrivateFieldSet(this, _flattenedNodes, flattenNode(node));
            // Since above properties aren't "attribute", their changes does not
            // trigger an update. We need to manually request an update.
            this.requestUpdate();
        }
        __updateEffectMargins() {
            if (!this.__images) {
                return;
            }
            const containers = Object.keys(this.__images)
                .map(ViewerMixin_classPrivateFieldGet(this, _getNodeById))
                .filter((n) => !!n);
            ViewerMixin_classPrivateFieldSet(this, _effectMargins, containers.reduce((margin, node) => {
                if (!("absoluteBoundingBox" in node)) {
                    return margin;
                }
                return Object.assign(Object.assign({}, margin), { [node.id]: getEffectMargin(node, flattenNode(node)) });
            }, {}));
            this.requestUpdate();
        }
        resetZoom() {
            if (ViewerMixin_classPrivateFieldGet(this, _canvasSize)) {
                // Set initial zoom level based on element size
                const { width, height } = ViewerMixin_classPrivateFieldGet(this, _canvasSize);
                const { width: elementWidth, height: elementHeight, } = this.getBoundingClientRect();
                const wDiff = elementWidth / (width + this.zoomMargin * 2);
                const hDiff = elementHeight / (height + this.zoomMargin * 2);
                this.scale = Math.min(wDiff, hDiff, 1);
            }
        }
    }
    _canvasSize = new WeakMap(), _effectMargins = new WeakMap(), _flattenedNodes = new WeakMap(), _handleNodeClick = new WeakMap(), _getNodeById = new WeakMap();
    ViewerMixin_decorate([
        property_e({
            type: Number,
            attribute: "zoom-margin",
        })
    ], Viewer.prototype, "zoomMargin", void 0);
    ViewerMixin_decorate([
        property_e({
            type: String,
            attribute: "link",
        })
    ], Viewer.prototype, "link", void 0);
    return Viewer;
};
function getCanvasSize(node) {
    const left = [];
    const right = [];
    const top = [];
    const bottom = [];
    for (const child of node.children) {
        if (child.type !== "FRAME" && child.type !== "COMPONENT") {
            continue;
        }
        const { x, y, width, height } = child.absoluteBoundingBox;
        left.push(x);
        right.push(x + width);
        top.push(y);
        bottom.push(y + height);
    }
    const minX = Math.min(...left);
    const minY = Math.min(...top);
    return {
        x: minX,
        y: minY,
        width: Math.abs(Math.max(...right) - minX),
        height: Math.abs(Math.min(...bottom) - minY),
    };
}
function getEffectMargin(container, nodes) {
    const points = nodes.map((node) => {
        if (!("effects" in node)) {
            return {
                top: node.absoluteBoundingBox.y,
                right: node.absoluteBoundingBox.x + node.absoluteBoundingBox.width,
                bottom: node.absoluteBoundingBox.y + node.absoluteBoundingBox.height,
                left: node.absoluteBoundingBox.x,
            };
        }
        const blurRadiuses = node.effects
            .filter((effect) => effect.visible && effect.type === "LAYER_BLUR")
            .map((effect) => effect.radius);
        const shadowMargins = node.effects
            .filter((effect) => effect.visible && effect.type === "DROP_SHADOW" && !!effect.offset)
            .map((effect) => {
            return {
                left: effect.radius - effect.offset.x,
                top: effect.radius - effect.offset.y,
                right: effect.radius + effect.offset.x,
                bottom: effect.radius + effect.offset.y,
            };
        });
        const margin = {
            top: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.top)),
            right: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.right)),
            bottom: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.bottom)),
            left: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.left)),
        };
        return {
            top: node.absoluteBoundingBox.y - margin.top,
            right: node.absoluteBoundingBox.x +
                node.absoluteBoundingBox.width +
                margin.right,
            bottom: node.absoluteBoundingBox.y +
                node.absoluteBoundingBox.height +
                margin.bottom,
            left: node.absoluteBoundingBox.x - margin.left,
        };
    });
    const bounds = {
        top: Math.min(...points.map((p) => p.top)),
        right: Math.max(...points.map((p) => p.right)),
        bottom: Math.max(...points.map((p) => p.bottom)),
        left: Math.min(...points.map((p) => p.left)),
    };
    return {
        top: container.absoluteBoundingBox.y - bounds.top,
        right: bounds.right -
            container.absoluteBoundingBox.x -
            container.absoluteBoundingBox.width,
        bottom: bounds.bottom -
            container.absoluteBoundingBox.y -
            container.absoluteBoundingBox.height,
        left: container.absoluteBoundingBox.x - bounds.left,
    };
}
function flattenNode(node, depth = 0) {
    if (!("absoluteBoundingBox" in node)) {
        return node.children.map((child) => flattenNode(child, depth + 1)).flat();
    }
    if (!("children" in node) || node.children.length === 0) {
        return [Object.assign(Object.assign({}, node), { depth })];
    }
    return [
        Object.assign(Object.assign({}, node), { depth }),
        ...node.children.map((child) => flattenNode(child, depth + 1)).flat(),
    ];
}

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/FigspecFrameViewer.js
var FigspecFrameViewer_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




// TODO: Move docs for props in mixins (waiting for support at web-component-analyzer)
/**
 * A Figma spec viewer. Displays a rendered image alongside sizing guides.
 * @element figspec-frame-viewer
 *
 * @property {number} [panX=0]
 * Current pan offset in px for X axis.
 * This is a "before the scale" value.
 *
 * @property {number} [panY=0]
 * Current pan offset in px for Y axis.
 * This is a "before the scale" value.
 *
 * @property {number} [scale=1]
 * Current zoom level, where 1.0 = 100%.
 *
 * @property {number} [zoomSpeed=500]
 * How fast zooming when do ctrl+scroll / pinch gestures.
 * Available values: 1 ~ 1000
 * @attr [zoom-speed=500] See docs for `zoomSpeed` property.
 *
 * @property {number} [panSpeed=500]
 * How fast panning when scroll vertically or horizontally.
 * This does not affect to dragging with middle button pressed.
 * Available values: 1 ~ 1000.
 * @attr [pan-speed=500] See docs for `panSpeed` property.
 *
 * @property {Figma.Node | null} [selectedNode=null]
 * Current selected node.
 *
 * @property {string} [link=null]
 * Figma link for the given project/node. If passed, figspec will present a footer with metadata and a link to figma.
 *
 * @property {number} [zoomMargin=50]
 * The minimum margin for the preview canvas in px. Will be used when the preview
 * setting a default zooming scale for the canvas.
 * @attr [zoom-margin=50] See docs for `zoomMargin` property.
 *
 * @fires scalechange When a user zoom-in or zoom-out the preview.
 * @fires positionchange When a user panned the preview.
 * @fires nodeselect When a user selected / unselected a node.
 */
class FigspecFrameViewer_FigspecFrameViewer extends ViewerMixin(lit_element_s) {
    constructor() {
        super(...arguments);
        /**
         * A response of "GET file nodes" API.
         * https://www.figma.com/developers/api#get-file-nodes-endpoint
         */
        this.nodes = null;
        /**
         * An image rendered by "GET image" API.
         * https://www.figma.com/developers/api#get-images-endpoint
         */
        this.renderedImage = null;
    }
    /** @private */
    get isMovable() {
        return !!(this.nodes && this.renderedImage && this.documentNode);
    }
    /**
     * Readonly. Document node (= root drawable node).
     * @readonly
     */
    get documentNode() {
        if (!this.nodes) {
            return null;
        }
        const documentNode = Object.values(this.nodes.nodes)[0];
        if (!documentNode || !("absoluteBoundingBox" in documentNode.document)) {
            return null;
        }
        return documentNode.document;
    }
    /** @private */
    get __images() {
        if (!this.documentNode || !this.renderedImage) {
            return {};
        }
        return {
            [this.documentNode.id]: this.renderedImage,
        };
    }
    /** @private */
    get error() {
        if (!this.nodes || !this.renderedImage) {
            return ErrorMessage({
                title: "Parameter error",
                children: $ `<span>
          Both <code>nodes</code> and <code>rendered-image</code> are required.
        </span>`,
            });
        }
        if (!this.documentNode) {
            return ErrorMessage({
                title: "Parameter Error",
                children: $ `
          <span> Document node is empty or does not have size. </span>
        `,
            });
        }
        if (super.error) {
            return super.error;
        }
    }
    getMetadata() {
        return {
            fileName: this.nodes.name,
            timestamp: this.nodes.lastModified,
            link: this.link,
        };
    }
    connectedCallback() {
        super.connectedCallback();
        if (this.documentNode) {
            this.__updateTree(this.documentNode);
            this.__updateEffectMargins();
            this.resetZoom();
        }
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (changedProperties.has("nodes")) {
            if (!this.documentNode)
                return;
            this.__updateTree(this.documentNode);
            this.resetZoom();
        }
        if (changedProperties.has("renderedImage")) {
            this.__updateEffectMargins();
        }
    }
}
FigspecFrameViewer_decorate([
    property_e({
        type: Object,
    })
], FigspecFrameViewer_FigspecFrameViewer.prototype, "nodes", void 0);
FigspecFrameViewer_decorate([
    property_e({
        type: String,
        attribute: "rendered-image",
    })
], FigspecFrameViewer_FigspecFrameViewer.prototype, "renderedImage", void 0);

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/FigspecFileViewer.js
var FigspecFileViewer_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FigspecFileViewer_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _selectFirstPage, _handlePageChange;





// TODO: Move docs for props in mixins (waiting for support at web-component-analyzer)
/**
 * A Figma spec viewer. Displays a rendered image alongside sizing guides.
 * @element figspec-file-viewer
 *
 * @property {number} [panX=0]
 * Current pan offset in px for X axis.
 * This is a "before the scale" value.
 *
 * @property {number} [panY=0]
 * Current pan offset in px for Y axis.
 * This is a "before the scale" value.
 *
 * @property {number} [scale=1]
 * Current zoom level, where 1.0 = 100%.
 *
 * @property {number} [zoomSpeed=500]
 * How fast zooming when do ctrl+scroll / pinch gestures.
 * Available values: 1 ~ 1000
 * @attr [zoom-speed=500] See docs for `zoomSpeed` property.
 *
 * @property {number} [panSpeed=500]
 * How fast panning when scroll vertically or horizontally.
 * This does not affect to dragging with middle button pressed.
 * Available values: 1 ~ 1000.
 * @attr [pan-speed=500] See docs for `panSpeed` property.
 *
 * @property {Figma.Node | null} [selectedNode=null]
 * Current selected node.
 *
 * @property {string} [link=null]
 * Figma link for the given project/node. If passed, figspec will present a footer with metadata and a link to figma.
 *
 * @property {number} [zoomMargin=50]
 * The minimum margin for the preview canvas in px. Will be used when the preview
 * setting a default zooming scale for the canvas.
 * @attr [zoom-margin=50] See docs for `zoomMargin` property.
 *
 * @fires scalechange When a user zoom-in or zoom-out the preview.
 * @fires positionchange When a user panned the preview.
 * @fires nodeselect When a user selected / unselected a node.
 */
class FigspecFileViewer_FigspecFileViewer extends ViewerMixin(lit_element_s) {
    constructor() {
        super(...arguments);
        /**
         * A response of "GET file nodes" API.
         * https://www.figma.com/developers/api#get-file-nodes-endpoint
         */
        this.documentNode = null;
        /**
         * A record of rendered images, where key is an ID of the node,
         * value is an URI of the image.
         * https://www.figma.com/developers/api#get-images-endpoint
         */
        this.renderedImages = null;
        /**
         * Current selected page (node whose type is "CANVAS").
         */
        this.selectedPage = null;
        _selectFirstPage.set(this, () => {
            var _a;
            if (!this.documentNode) {
                this.selectedPage = null;
                return;
            }
            this.selectedPage = (_a = this.documentNode.document.children.filter((c) => c.type === "CANVAS")[0]) !== null && _a !== void 0 ? _a : null;
        });
        _handlePageChange.set(this, (ev) => {
            var _a, _b;
            const target = ev.currentTarget;
            this.selectedPage = (_b = (_a = this.documentNode) === null || _a === void 0 ? void 0 : _a.document.children.find((c) => c.id === target.value)) !== null && _b !== void 0 ? _b : null;
            if (this.selectedPage) {
                this.__updateTree(this.selectedPage);
                this.resetZoom();
                this.__updateEffectMargins();
                this.panX = 0;
                this.panY = 0;
            }
        });
    }
    /** @private */
    get isMovable() {
        return !!(this.renderedImages && this.documentNode);
    }
    /** @private */
    get __images() {
        return this.renderedImages || {};
    }
    /** @private */
    get error() {
        if (!this.documentNode || !this.renderedImages) {
            return ErrorMessage({
                title: "Parameter error",
                children: $ `<span>
          Both <code>document-node</code> and <code>rendered-images</code> are
          required.
        </span>`,
            });
        }
        if (super.error) {
            return super.error;
        }
    }
    static get styles() {
        return extendStyles(super.styles, [
            css_tag_r `
        :host {
          --figspec-control-bg-default: #fcfcfc;
          --figspec-control-fg-default: #333;

          --control-bg: var(
            --figspec-control-bg,
            var(--figspec-control-bg-default)
          );
          --control-fg: var(
            --figspec-control-bg,
            var(--figspec-control-fg-default)
          );
          --control-shadow: var(
            --figspec-control-shadow,
            0 2px 4px rgba(0, 0, 0, 0.3)
          );
          --padding: var(--figspec-control-padding, 8px 16px);

          display: flex;
          flex-direction: column;
        }

        @media (prefers-color-scheme: dark) {
          :host {
            --figspec-control-bg-default: #222;
            --figspec-control-fg-default: #fff;
          }
        }

        .controls {
          flex-shrink: 0;
          padding: var(--padding);

          background-color: var(--control-bg);
          box-shadow: var(--control-shadow);
          color: var(--control-fg);
          z-index: 1;
        }

        .view {
          position: relative;
          flex-grow: 1;
          flex-shrink: 1;
        }
      `,
        ]);
    }
    render() {
        var _a;
        return $ `
      <div class="controls">
        <select @change=${FigspecFileViewer_classPrivateFieldGet(this, _handlePageChange)}>
          ${(_a = this.documentNode) === null || _a === void 0 ? void 0 : _a.document.children.map((c) => $ `<option value=${c.id}>${c.name}</option>`)}
        </select>
      </div>

      <div class="view">${super.render()}</div>
    `;
    }
    getMetadata() {
        return {
            fileName: this.documentNode.name,
            timestamp: this.documentNode.lastModified,
            link: this.link,
        };
    }
    connectedCallback() {
        super.connectedCallback();
        if (this.documentNode) {
            FigspecFileViewer_classPrivateFieldGet(this, _selectFirstPage).call(this);
            if (this.selectedPage) {
                this.__updateTree(this.selectedPage);
                this.resetZoom();
            }
        }
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (changedProperties.has("documentNode")) {
            FigspecFileViewer_classPrivateFieldGet(this, _selectFirstPage).call(this);
            if (this.selectedPage) {
                this.__updateTree(this.selectedPage);
                this.resetZoom();
            }
        }
        if (changedProperties.has("renderedImages")) {
            this.__updateEffectMargins();
        }
    }
}
_selectFirstPage = new WeakMap(), _handlePageChange = new WeakMap();
FigspecFileViewer_decorate([
    property_e({
        type: Object,
        attribute: "document-node",
    })
], FigspecFileViewer_FigspecFileViewer.prototype, "documentNode", void 0);
FigspecFileViewer_decorate([
    property_e({
        type: Object,
        attribute: "rendered-images",
    })
], FigspecFileViewer_FigspecFileViewer.prototype, "renderedImages", void 0);

// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/index.js


if (!customElements.get("figspec-file-viewer")) {
    customElements.define("figspec-file-viewer", FigspecFileViewer_FigspecFileViewer);
}
if (!customElements.get("figspec-frame-viewer")) {
    customElements.define("figspec-frame-viewer", FigspecFrameViewer_FigspecFrameViewer);
}



// CONCATENATED MODULE: ./node_modules/@lit-labs/react/create-component.js
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const create_component_t=new Set(["children","localName","ref","style","className"]),create_component_e=new WeakMap,create_component_n=(t,n,s,o,i)=>{const l=null==i?void 0:i[n];void 0!==l?s!==o&&((t,n,s)=>{let o=create_component_e.get(t);void 0===o&&create_component_e.set(t,o=new Map);let i=o.get(n);void 0!==s?void 0===i?(o.set(n,i={handleEvent:s}),t.addEventListener(n,i)):i.handleEvent=s:void 0!==i&&(o.delete(n),t.removeEventListener(n,i))})(t,l,s):t[n]=s},create_component_s=(e,s,o,i,l)=>{const c=e.Component,r=e.createElement,d=new Set(Object.keys(null!=i?i:{}));for(const e in o.prototype)e in HTMLElement.prototype||(create_component_t.has(e)?console.warn(`${s} contains property ${e} which is a React reserved property. It will be used by React and not set on the element.`):d.add(e));class h extends c{constructor(){super(...arguments),this.t=null}o(t){if(null!==this.t)for(const e in this.i)create_component_n(this.t,e,this.props[e],t?t[e]:void 0,i)}componentDidMount(){this.o()}componentDidUpdate(t){this.o(t)}render(){const t=this.props.l;void 0!==this.h&&this.u===t||(this.h=e=>{null===this.t&&(this.t=e),null!==t&&((t,e)=>{"function"==typeof t?t(e):t.current=e})(t,e),this.u=t});const e={ref:this.h};this.i={};for(const[t,n]of Object.entries(this.props))"__forwardedRef"!==t&&(d.has(t)?this.i[t]=n:e["className"===t?"class":t]=n);return r(s,e)}}h.displayName=null!=l?l:o.name;const a=e.forwardRef(((t,e)=>r(h,{...t,l:e},null==t?void 0:t.children)));return a.displayName=h.displayName,a};
//# sourceMappingURL=create-component.js.map

// CONCATENATED MODULE: ./node_modules/@lit-labs/react/index.js

//# sourceMappingURL=index.js.map

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");

// CONCATENATED MODULE: ./node_modules/@figspec/react/esm/es2015/index.js



// NOTE: These exported components are casted with `as unknown as ...` in order not to break
//       typings accidentally. `as unknown` is required because a component created by
//       `createComponent` has `RefAttributes<unknown>`, which is incompatible with existing
//       type signature (and breaks ref typings). Also the explicit props definition prevents
//       every properties turns into optional.
const es2015_FigspecFrameViewer = create_component_s(react, "figspec-frame-viewer", FigspecFrameViewer_FigspecFrameViewer, {
    onNodeSelect: "nodeselect",
    onPositionChange: "positionchange",
    onScaleChange: "scalechange",
});
const es2015_FigspecFileViewer = create_component_s(react, "figspec-file-viewer", FigspecFileViewer_FigspecFileViewer, {
    onNodeSelect: "nodeselect",
    onPositionChange: "positionchange",
    onScaleChange: "scalechange",
});


/***/ }),

/***/ "./node_modules/storybook-addon-designs/esm/register/components/Figspec.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/storybook-addon-designs/esm/register/components/Figspec.js ***!
  \*********************************************************************************/
/*! exports provided: Figspec, default */
/*! all exports used */
/*! ModuleConcatenation bailout: Module uses injected variables (process) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Figspec", function() { return Figspec; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _figspec_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @figspec/react */ "./node_modules/@figspec/react/esm/es2015/index.js");
/* harmony import */ var _storybook_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @storybook/components */ "./node_modules/@storybook/components/dist/esm/placeholder/placeholder.js");
/* harmony import */ var _storybook_theming__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @storybook/theming */ "./node_modules/@emotion/core/dist/core.browser.esm.js");
/* harmony import */ var _Figma__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Figma */ "./node_modules/storybook-addon-designs/esm/register/components/Figma.js");
var __makeTemplateObject = (undefined && undefined.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};





var fullscreen = Object(_storybook_theming__WEBPACK_IMPORTED_MODULE_3__[/* css */ "c"])(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n"], ["\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n"])));
function unwrapJson(res) {
    return res.status !== 200 ? Promise.reject(res.statusText) : res.json();
}
function getAccessToken(cfg) {
    var _a;
    if (cfg.accessToken) {
        return cfg.accessToken;
    }
    try {
        return (_a = process.env.STORYBOOK_FIGMA_ACCESS_TOKEN) !== null && _a !== void 0 ? _a : null;
    }
    catch (err) {
        return null;
    }
}
var Figspec = function (_a) {
    var config = _a.config;
    var _b = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])({
        state: 'loading',
    }), state = _b[0], setState = _b[1];
    var fetchDetails = function (signal) { return __awaiter(void 0, void 0, void 0, function () {
        var match, fileKey, url, nodeId, accessToken, headers, nodeUrl, imageUrl, documentNode, frames_1, images_1, _a, nodes, images, err_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    setState({ state: 'loading' });
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, , 7]);
                    match = config.url.match(_Figma__WEBPACK_IMPORTED_MODULE_4__[/* figmaURLPattern */ "b"]);
                    if (!match) {
                        throw new Error(config.url + ' is not a valid Figma URL.');
                    }
                    fileKey = match[3];
                    url = new URL(config.url);
                    nodeId = url.searchParams.get('node-id');
                    accessToken = getAccessToken(config);
                    if (!accessToken) {
                        throw new Error('Personal Access Token is required.');
                    }
                    headers = {
                        'X-FIGMA-TOKEN': accessToken,
                    };
                    nodeUrl = new URL("https://api.figma.com/v1/files/" + fileKey);
                    imageUrl = new URL("https://api.figma.com/v1/images/" + fileKey);
                    imageUrl.searchParams.set('format', 'svg');
                    if (!!nodeId) return [3, 4];
                    return [4, fetch(nodeUrl.href, {
                            headers: headers,
                            signal: signal,
                        }).then(unwrapJson)];
                case 2:
                    documentNode = _b.sent();
                    frames_1 = listAllFrames(documentNode.document);
                    imageUrl.searchParams.set('ids', frames_1.map(function (frame) { return frame.id; }).join(','));
                    return [4, fetch(imageUrl.href, {
                            headers: headers,
                            signal: signal,
                        }).then(unwrapJson)];
                case 3:
                    images_1 = _b.sent();
                    setState({
                        state: 'fetched',
                        value: {
                            type: 'file',
                            props: {
                                documentNode: documentNode,
                                renderedImages: images_1.images,
                                link: config.url
                            },
                        },
                    });
                    return [2];
                case 4:
                    nodeUrl.pathname += '/nodes';
                    nodeUrl.searchParams.set('ids', nodeId);
                    imageUrl.searchParams.set('ids', nodeId);
                    return [4, Promise.all([
                            fetch(nodeUrl.href, {
                                headers: headers,
                                signal: signal,
                            }).then(unwrapJson),
                            fetch(imageUrl.href, { headers: headers, signal: signal }).then(unwrapJson),
                        ])];
                case 5:
                    _a = _b.sent(), nodes = _a[0], images = _a[1];
                    setState({
                        state: 'fetched',
                        value: {
                            type: 'frame',
                            props: {
                                nodes: nodes,
                                renderedImage: Object.values(images.images)[0],
                                link: config.url
                            },
                        },
                    });
                    return [3, 7];
                case 6:
                    err_1 = _b.sent();
                    if (err_1 instanceof DOMException && err_1.code === DOMException.ABORT_ERR) {
                        return [2];
                    }
                    console.error(err_1);
                    setState({
                        state: 'failed',
                        error: err_1 instanceof Error ? err_1.message : String(err_1),
                    });
                    return [3, 7];
                case 7: return [2];
            }
        });
    }); };
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
        var fulfilled = false;
        var fulfil = function () {
            fulfilled = true;
        };
        var ac = new AbortController();
        fetchDetails(ac.signal).then(fulfil, fulfil);
        return function () {
            if (!fulfilled) {
                ac.abort();
            }
        };
    }, [config.url]);
    switch (state.state) {
        case 'loading':
            return (Object(_storybook_theming__WEBPACK_IMPORTED_MODULE_3__[/* jsx */ "d"])(_storybook_components__WEBPACK_IMPORTED_MODULE_2__[/* Placeholder */ "a"], null,
                Object(_storybook_theming__WEBPACK_IMPORTED_MODULE_3__[/* jsx */ "d"])(react__WEBPACK_IMPORTED_MODULE_0__["Fragment"], null, "Loading Figma file...")));
        case 'failed':
            return (Object(_storybook_theming__WEBPACK_IMPORTED_MODULE_3__[/* jsx */ "d"])(_storybook_components__WEBPACK_IMPORTED_MODULE_2__[/* Placeholder */ "a"], null,
                Object(_storybook_theming__WEBPACK_IMPORTED_MODULE_3__[/* jsx */ "d"])(react__WEBPACK_IMPORTED_MODULE_0__["Fragment"], null, "Failed to load Figma file"),
                Object(_storybook_theming__WEBPACK_IMPORTED_MODULE_3__[/* jsx */ "d"])(react__WEBPACK_IMPORTED_MODULE_0__["Fragment"], null, state.error)));
        case 'fetched':
            return state.value.type === 'file' ? (Object(_storybook_theming__WEBPACK_IMPORTED_MODULE_3__[/* jsx */ "d"])(_figspec_react__WEBPACK_IMPORTED_MODULE_1__[/* FigspecFileViewer */ "a"], __assign({ css: fullscreen }, state.value.props))) : (Object(_storybook_theming__WEBPACK_IMPORTED_MODULE_3__[/* jsx */ "d"])(_figspec_react__WEBPACK_IMPORTED_MODULE_1__[/* FigspecFrameViewer */ "b"], __assign({ css: fullscreen }, state.value.props)));
    }
};
/* harmony default export */ __webpack_exports__["default"] = (Figspec);
function listAllFrames(node) {
    if ('absoluteBoundingBox' in node) {
        return [node];
    }
    if (!node.children || node.children.length === 0) {
        return [];
    }
    return node.children.map(listAllFrames).flat();
}
var templateObject_1;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ })

}]);